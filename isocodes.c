/* isocodes.c generated by valac 0.16.0, the Vala compiler
 * generated from isocodes.vala, do not modify */

/* Copyright Â© 2012 Tobias Quathamer
 *
 * This file is part of libisocodes.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>


#define ISOCODES_TYPE_ISO_CODES (isocodes_iso_codes_get_type ())
#define ISOCODES_ISO_CODES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ISOCODES_TYPE_ISO_CODES, isocodesISO_Codes))
#define ISOCODES_ISO_CODES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ISOCODES_TYPE_ISO_CODES, isocodesISO_CodesClass))
#define ISOCODES_IS_ISO_CODES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ISOCODES_TYPE_ISO_CODES))
#define ISOCODES_IS_ISO_CODES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ISOCODES_TYPE_ISO_CODES))
#define ISOCODES_ISO_CODES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ISOCODES_TYPE_ISO_CODES, isocodesISO_CodesClass))

typedef struct _isocodesISO_Codes isocodesISO_Codes;
typedef struct _isocodesISO_CodesClass isocodesISO_CodesClass;
typedef struct _isocodesISO_CodesPrivate isocodesISO_CodesPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _isocodesISO_Codes {
	GObject parent_instance;
	isocodesISO_CodesPrivate * priv;
	xmlDoc* _xml;
};

struct _isocodesISO_CodesClass {
	GObjectClass parent_class;
};

struct _isocodesISO_CodesPrivate {
	gchar* _filepath;
	gchar* _standard;
};

typedef enum  {
	ISOCODES_ISO_CODES_ERROR_FILE_DOES_NOT_EXIST,
	ISOCODES_ISO_CODES_ERROR_CANNOT_PARSE_FILE,
	ISOCODES_ISO_CODES_ERROR_FILE_DOES_NOT_CONTAIN_ISO_DATA,
	ISOCODES_ISO_CODES_ERROR_CODE_NOT_DEFINED
} isocodesISOCodesError;
#define ISOCODES_ISO_CODES_ERROR isocodes_iso_codes_error_quark ()

static gpointer isocodes_iso_codes_parent_class = NULL;

GType isocodes_iso_codes_get_type (void) G_GNUC_CONST;
#define ISOCODES_ISO_CODES_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ISOCODES_TYPE_ISO_CODES, isocodesISO_CodesPrivate))
enum  {
	ISOCODES_ISO_CODES_DUMMY_PROPERTY,
	ISOCODES_ISO_CODES_FILEPATH,
	ISOCODES_ISO_CODES_STANDARD
};
GQuark isocodes_iso_codes_error_quark (void);
void isocodes_iso_codes_open_file (isocodesISO_Codes* self, const gchar* name, GError** error);
void isocodes_iso_codes_set_filepath (isocodesISO_Codes* self, const gchar* value);
const gchar* isocodes_iso_codes_get_filepath (isocodesISO_Codes* self);
const gchar* isocodes_iso_codes_get_standard (isocodesISO_Codes* self);
xmlNode** _isocodes_iso_codes_find_code_in_attributes (isocodesISO_Codes* self, gchar** attributes, int attributes_length1, const gchar* code, int* result_length1, GError** error);
static void _vala_array_add1 (xmlNode*** array, int* length, int* size, xmlNode* value);
isocodesISO_Codes* isocodes_iso_codes_new (void);
isocodesISO_Codes* isocodes_iso_codes_construct (GType object_type);
void isocodes_iso_codes_set_standard (isocodesISO_Codes* self, const gchar* value);
static void isocodes_iso_codes_finalize (GObject* obj);
static void _vala_isocodes_iso_codes_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_isocodes_iso_codes_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


/**
         * Open and parse the file.
         * 
         * This method checks that the file exists and tries to parse
         * it.
         * 
         * @param string Filename to open, defaults to filepath.
         * @param string ISO standard to expect in the file.
         */
static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


void isocodes_iso_codes_open_file (isocodesISO_Codes* self, const gchar* name, GError** error) {
	const gchar* _tmp0_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	xmlDoc* _tmp14_ = NULL;
	xmlDoc* _tmp15_;
	xmlDoc* _tmp23_;
	xmlNode* _tmp24_ = NULL;
	const gchar* _tmp25_;
	gchar* _tmp26_;
	gchar* root_name;
	const gchar* _tmp27_;
	gchar* _tmp28_ = NULL;
	gchar* _tmp29_;
	const gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* expected_name;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = name;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		const gchar* _tmp1_;
		_tmp1_ = name;
		isocodes_iso_codes_set_filepath (self, _tmp1_);
	}
	_tmp2_ = isocodes_iso_codes_get_filepath (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_file_test (_tmp3_, G_FILE_TEST_EXISTS);
	if (_tmp4_ == FALSE) {
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		GError* _tmp10_;
		GError* _tmp11_;
		_tmp5_ = isocodes_iso_codes_get_filepath (self);
		_tmp6_ = _tmp5_;
		_tmp7_ = string_to_string (_tmp6_);
		_tmp8_ = g_strconcat ("The file '", _tmp7_, "' does not exist.", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_error_new_literal (ISOCODES_ISO_CODES_ERROR, ISOCODES_ISO_CODES_ERROR_FILE_DOES_NOT_EXIST, _tmp9_);
		_tmp11_ = _tmp10_;
		_g_free0 (_tmp9_);
		_inner_error_ = _tmp11_;
		if (_inner_error_->domain == ISOCODES_ISO_CODES_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp12_ = isocodes_iso_codes_get_filepath (self);
	_tmp13_ = _tmp12_;
	_tmp14_ = xmlParseFile (_tmp13_);
	self->_xml = _tmp14_;
	_tmp15_ = self->_xml;
	if (_tmp15_ == NULL) {
		const gchar* _tmp16_;
		const gchar* _tmp17_;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		GError* _tmp21_;
		GError* _tmp22_;
		_tmp16_ = isocodes_iso_codes_get_filepath (self);
		_tmp17_ = _tmp16_;
		_tmp18_ = string_to_string (_tmp17_);
		_tmp19_ = g_strconcat ("The file '", _tmp18_, "' could not be parsed correctly.", NULL);
		_tmp20_ = _tmp19_;
		_tmp21_ = g_error_new_literal (ISOCODES_ISO_CODES_ERROR, ISOCODES_ISO_CODES_ERROR_CANNOT_PARSE_FILE, _tmp20_);
		_tmp22_ = _tmp21_;
		_g_free0 (_tmp20_);
		_inner_error_ = _tmp22_;
		if (_inner_error_->domain == ISOCODES_ISO_CODES_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp23_ = self->_xml;
	_tmp24_ = xmlDocGetRootElement (_tmp23_);
	_tmp25_ = _tmp24_->name;
	_tmp26_ = g_strdup (_tmp25_);
	root_name = _tmp26_;
	_tmp27_ = self->priv->_standard;
	_tmp28_ = string_replace (_tmp27_, "-", "_");
	_tmp29_ = _tmp28_;
	_g_free0 (_tmp29_);
	_tmp30_ = self->priv->_standard;
	_tmp31_ = g_strconcat ("iso_", _tmp30_, NULL);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strconcat (_tmp32_, "_entries", NULL);
	_tmp34_ = _tmp33_;
	_g_free0 (_tmp32_);
	expected_name = _tmp34_;
	if (g_strcmp0 (root_name, expected_name) != 0) {
		const gchar* _tmp35_;
		const gchar* _tmp36_;
		const gchar* _tmp37_ = NULL;
		const gchar* _tmp38_;
		const gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		gchar* _tmp41_;
		GError* _tmp42_;
		GError* _tmp43_;
		_tmp35_ = isocodes_iso_codes_get_filepath (self);
		_tmp36_ = _tmp35_;
		_tmp37_ = string_to_string (_tmp36_);
		_tmp38_ = self->priv->_standard;
		_tmp39_ = string_to_string (_tmp38_);
		_tmp40_ = g_strconcat ("The file '", _tmp37_, "' does not contain valid ISO ", _tmp39_, " data.", NULL);
		_tmp41_ = _tmp40_;
		_tmp42_ = g_error_new_literal (ISOCODES_ISO_CODES_ERROR, ISOCODES_ISO_CODES_ERROR_FILE_DOES_NOT_CONTAIN_ISO_DATA, _tmp41_);
		_tmp43_ = _tmp42_;
		_g_free0 (_tmp41_);
		_inner_error_ = _tmp43_;
		if (_inner_error_->domain == ISOCODES_ISO_CODES_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (expected_name);
			_g_free0 (root_name);
			return;
		} else {
			_g_free0 (expected_name);
			_g_free0 (root_name);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_g_free0 (expected_name);
	_g_free0 (root_name);
}


static void _vala_array_add1 (xmlNode*** array, int* length, int* size, xmlNode* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (xmlNode*, *array, *size);
	}
	(*array)[(*length)++] = value;
}


xmlNode** _isocodes_iso_codes_find_code_in_attributes (isocodesISO_Codes* self, gchar** attributes, int attributes_length1, const gchar* code, int* result_length1, GError** error) {
	xmlNode** result = NULL;
	xmlNode** _tmp0_ = NULL;
	xmlNode** _result_;
	gint _result__length1;
	gint __result__size_;
	gboolean code_found;
	xmlDoc* _tmp1_;
	xmlNode* _tmp2_ = NULL;
	xmlNode* _tmp3_;
	xmlNode* iterator;
	gboolean _tmp21_;
	xmlNode* _tmp28_;
	xmlNode** _tmp29_;
	gint _tmp29__length1;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (code != NULL, NULL);
	_tmp0_ = g_new0 (xmlNode*, 0);
	_result_ = _tmp0_;
	_result__length1 = 0;
	__result__size_ = _result__length1;
	code_found = FALSE;
	_tmp1_ = self->_xml;
	_tmp2_ = xmlDocGetRootElement (_tmp1_);
	_tmp3_ = _tmp2_->children;
	iterator = _tmp3_;
	while (TRUE) {
		xmlNode* _tmp4_;
		xmlNode* _tmp5_;
		xmlElementType _tmp6_;
		xmlNode* _tmp19_;
		xmlNode* _tmp20_;
		_tmp4_ = iterator;
		if (!(_tmp4_ != NULL)) {
			break;
		}
		_tmp5_ = iterator;
		_tmp6_ = _tmp5_->type;
		if (_tmp6_ == XML_ELEMENT_NODE) {
			xmlNode* _tmp7_;
			const gchar* _tmp8_;
			_tmp7_ = iterator;
			_tmp8_ = _tmp7_->name;
			if (g_strcmp0 (_tmp8_, "iso_3166_entry") == 0) {
				gchar** _tmp9_;
				gint _tmp9__length1;
				_tmp9_ = attributes;
				_tmp9__length1 = attributes_length1;
				{
					gchar** attribute_collection = NULL;
					gint attribute_collection_length1 = 0;
					gint _attribute_collection_size_ = 0;
					gint attribute_it = 0;
					attribute_collection = _tmp9_;
					attribute_collection_length1 = _tmp9__length1;
					for (attribute_it = 0; attribute_it < _tmp9__length1; attribute_it = attribute_it + 1) {
						gchar* _tmp10_;
						gchar* attribute = NULL;
						_tmp10_ = g_strdup (attribute_collection[attribute_it]);
						attribute = _tmp10_;
						{
							xmlNode* _tmp11_;
							const gchar* _tmp12_;
							gchar* _tmp13_ = NULL;
							gchar* _tmp14_;
							const gchar* _tmp15_;
							gboolean _tmp16_;
							_tmp11_ = iterator;
							_tmp12_ = attribute;
							_tmp13_ = xmlGetProp (_tmp11_, _tmp12_);
							_tmp14_ = _tmp13_;
							_tmp15_ = code;
							_tmp16_ = g_strcmp0 (_tmp14_, _tmp15_) == 0;
							_g_free0 (_tmp14_);
							if (_tmp16_) {
								xmlNode** _tmp17_;
								gint _tmp17__length1;
								xmlNode* _tmp18_;
								_tmp17_ = _result_;
								_tmp17__length1 = _result__length1;
								_tmp18_ = iterator;
								_vala_array_add1 (&_result_, &_result__length1, &__result__size_, _tmp18_);
								code_found = TRUE;
								_g_free0 (attribute);
								break;
							}
							_g_free0 (attribute);
						}
					}
				}
			}
		}
		_tmp19_ = iterator;
		_tmp20_ = _tmp19_->next;
		iterator = _tmp20_;
	}
	_tmp21_ = code_found;
	if (!_tmp21_) {
		const gchar* _tmp22_;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_;
		GError* _tmp26_;
		GError* _tmp27_;
		_tmp22_ = code;
		_tmp23_ = string_to_string (_tmp22_);
		_tmp24_ = g_strconcat ("The code '", _tmp23_, "' is not defined.", NULL);
		_tmp25_ = _tmp24_;
		_tmp26_ = g_error_new_literal (ISOCODES_ISO_CODES_ERROR, ISOCODES_ISO_CODES_ERROR_CODE_NOT_DEFINED, _tmp25_);
		_tmp27_ = _tmp26_;
		_g_free0 (_tmp25_);
		_inner_error_ = _tmp27_;
		if (_inner_error_->domain == ISOCODES_ISO_CODES_ERROR) {
			g_propagate_error (error, _inner_error_);
			_result_ = (g_free (_result_), NULL);
			return NULL;
		} else {
			_result_ = (g_free (_result_), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp28_ = iterator;
	xmlFreeNode (_tmp28_);
	_tmp29_ = _result_;
	_tmp29__length1 = _result__length1;
	if (result_length1) {
		*result_length1 = _tmp29__length1;
	}
	result = _tmp29_;
	return result;
}


isocodesISO_Codes* isocodes_iso_codes_construct (GType object_type) {
	isocodesISO_Codes * self = NULL;
	self = (isocodesISO_Codes*) g_object_new (object_type, NULL);
	return self;
}


isocodesISO_Codes* isocodes_iso_codes_new (void) {
	return isocodes_iso_codes_construct (ISOCODES_TYPE_ISO_CODES);
}


const gchar* isocodes_iso_codes_get_filepath (isocodesISO_Codes* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filepath;
	result = _tmp0_;
	return result;
}


void isocodes_iso_codes_set_filepath (isocodesISO_Codes* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	xmlDoc* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filepath);
	self->priv->_filepath = _tmp1_;
	_tmp2_ = self->_xml;
	if (_tmp2_ != NULL) {
		xmlDoc* _tmp3_;
		_tmp3_ = self->_xml;
		xmlFreeDoc (_tmp3_);
		self->_xml = NULL;
	}
	g_object_notify ((GObject *) self, "filepath");
}


const gchar* isocodes_iso_codes_get_standard (isocodesISO_Codes* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_standard;
	result = _tmp0_;
	return result;
}


void isocodes_iso_codes_set_standard (isocodesISO_Codes* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_standard);
	self->priv->_standard = _tmp1_;
	g_object_notify ((GObject *) self, "standard");
}


static void isocodes_iso_codes_class_init (isocodesISO_CodesClass * klass) {
	isocodes_iso_codes_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (isocodesISO_CodesPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_isocodes_iso_codes_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_isocodes_iso_codes_set_property;
	G_OBJECT_CLASS (klass)->finalize = isocodes_iso_codes_finalize;
	/**
	         * Get and set methods for path of the XML file.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ISOCODES_ISO_CODES_FILEPATH, g_param_spec_string ("filepath", "filepath", "filepath", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	         * The ISO standard currently in use.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), ISOCODES_ISO_CODES_STANDARD, g_param_spec_string ("standard", "standard", "standard", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void isocodes_iso_codes_instance_init (isocodesISO_Codes * self) {
	self->priv = ISOCODES_ISO_CODES_GET_PRIVATE (self);
	self->_xml = NULL;
}


static void isocodes_iso_codes_finalize (GObject* obj) {
	isocodesISO_Codes * self;
	self = ISOCODES_ISO_CODES (obj);
	_g_free0 (self->priv->_filepath);
	_g_free0 (self->priv->_standard);
	G_OBJECT_CLASS (isocodes_iso_codes_parent_class)->finalize (obj);
}


GType isocodes_iso_codes_get_type (void) {
	static volatile gsize isocodes_iso_codes_type_id__volatile = 0;
	if (g_once_init_enter (&isocodes_iso_codes_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (isocodesISO_CodesClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) isocodes_iso_codes_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (isocodesISO_Codes), 0, (GInstanceInitFunc) isocodes_iso_codes_instance_init, NULL };
		GType isocodes_iso_codes_type_id;
		isocodes_iso_codes_type_id = g_type_register_static (G_TYPE_OBJECT, "isocodesISO_Codes", &g_define_type_info, 0);
		g_once_init_leave (&isocodes_iso_codes_type_id__volatile, isocodes_iso_codes_type_id);
	}
	return isocodes_iso_codes_type_id__volatile;
}


static void _vala_isocodes_iso_codes_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	isocodesISO_Codes * self;
	self = ISOCODES_ISO_CODES (object);
	switch (property_id) {
		case ISOCODES_ISO_CODES_FILEPATH:
		g_value_set_string (value, isocodes_iso_codes_get_filepath (self));
		break;
		case ISOCODES_ISO_CODES_STANDARD:
		g_value_set_string (value, isocodes_iso_codes_get_standard (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_isocodes_iso_codes_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	isocodesISO_Codes * self;
	self = ISOCODES_ISO_CODES (object);
	switch (property_id) {
		case ISOCODES_ISO_CODES_FILEPATH:
		isocodes_iso_codes_set_filepath (self, g_value_get_string (value));
		break;
		case ISOCODES_ISO_CODES_STANDARD:
		isocodes_iso_codes_set_standard (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



